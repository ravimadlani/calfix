# CalFix SaaS Transformation Plan
## User Management & Persistent Storage Strategy

**Document Version:** 1.0
**Last Updated:** October 2025
**Author:** CalFix Development Team

---

## Table of Contents

1. [Executive Summary](#executive-summary)
2. [Current vs. Proposed Architecture](#architecture)
3. [Technology Stack](#technology-stack)
4. [Data Model](#data-model)
5. [Privacy & Security](#privacy-security)
6. [Cost Analysis](#cost-analysis)
7. [Implementation Plan](#implementation-plan)
8. [Deployment Strategy](#deployment-strategy)
9. [Risk Mitigation](#risk-mitigation)
10. [Privacy Policy Updates](#privacy-policy)
11. [Timeline & Next Steps](#timeline)

---

## Executive Summary

### Problem Statement

CalFix currently operates as a client-only application using localStorage for:
- Google OAuth tokens
- User action history (event IDs + metadata)
- User preferences

**Limitations:**
- âŒ Data lost when browser cache is cleared
- âŒ No cross-device sync
- âŒ Cannot implement user accounts or billing
- âŒ Cannot sell as SaaS product
- âŒ Limited to 100 test users in Google OAuth (Testing mode)

### Proposed Solution

Add **Clerk (authentication)** and **Supabase (database)** while maintaining privacy-first architecture:

- âœ… Persistent user accounts with billing
- âœ… Cross-device data sync
- âœ… User action history preserved
- âœ… SaaS-ready with subscription tiers
- âœ… Google OAuth verification (production mode)
- âœ… **Privacy maintained:** Calendar data NEVER stored in database

### Key Principles

1. **Privacy-First:** Only event IDs stored, never calendar content
2. **Client-Side Processing:** Calendar data processed in browser only
3. **Zero Trust:** Row-Level Security (RLS) prevents cross-user access
4. **User Control:** Users can export/delete all data anytime

---

## Architecture

### Current Architecture (Client-Only)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚          User's Browser                 â”‚
â”‚                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  CalFix React App (Vite)          â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ Google OAuth (PKCE)          â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ localStorage                 â”‚ â”‚
â”‚  â”‚  â”‚   â”œâ”€â”€ OAuth tokens             â”‚ â”‚
â”‚  â”‚  â”‚   â”œâ”€â”€ User actions (event IDs) â”‚ â”‚
â”‚  â”‚  â”‚   â””â”€â”€ User preferences         â”‚ â”‚
â”‚  â”‚  â””â”€â”€ Direct API calls              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚              â”‚                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
               â”‚
               â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Google Calendar API â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Characteristics:**
- 100% client-side
- Maximum privacy
- No user accounts
- Data lost on cache clear
- Cannot monetize

### Proposed Architecture (Client + Backend Services)

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    User's Browser                       â”‚
â”‚                                                         â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚  CalFix React App (Vite + TypeScript)             â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ Clerk Auth Provider                          â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ Supabase Client                              â”‚ â”‚
â”‚  â”‚  â”œâ”€â”€ localStorage (OAuth tokens only)             â”‚ â”‚
â”‚  â”‚  â””â”€â”€ Direct Google Calendar API calls             â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â”‚              â”‚              â”‚                 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
          â”‚              â”‚              â”‚
          â”‚              â”‚              â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
          â”‚              â”‚                                 â”‚
          â–¼              â–¼                                 â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚  Clerk  â”‚   â”‚  Supabase    â”‚         â”‚  Google Calendar API â”‚
    â”‚  Auth   â”‚   â”‚  Database    â”‚         â”‚                      â”‚
    â”‚         â”‚   â”‚              â”‚         â”‚  (Calendar data      â”‚
    â”‚ â€¢ Users â”‚   â”‚ â€¢ Actions    â”‚         â”‚   never stored)      â”‚
    â”‚ â€¢ JWT   â”‚   â”‚ â€¢ Prefs      â”‚         â”‚                      â”‚
    â”‚ â€¢ Stripeâ”‚   â”‚ â€¢ Stats      â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

**Characteristics:**
- User accounts with authentication
- Persistent data storage (event IDs only)
- Cross-device sync
- Billing & subscriptions
- **Privacy maintained:** Calendar data still processed client-side only

---

## Technology Stack

### Authentication: Clerk

**Why Clerk?**

| Feature | Benefit |
|---------|---------|
| Pre-built React components | Sign-in, sign-up, user profile UI ready to use |
| Session management | Automatic JWT refresh, secure sessions |
| Multiple auth providers | Email, Google, GitHub, etc. |
| Billing integration | Stripe built-in (critical for SaaS) |
| User management UI | Admin dashboard included |
| Webhooks | User lifecycle events (created, updated, deleted) |
| Great DX | Minimal code, well-documented |

**Pricing:**
- Free: 10,000 MAU (Monthly Active Users)
- Paid: $25/month + $0.02/user after 10,000

**Alternatives Considered:**
- **Supabase Auth** - Free but less polished, no Stripe integration
- **Auth0** - More expensive ($23/mo + $0.05/user)
- **Firebase Auth** - Good but locks into Google ecosystem
- **NextAuth.js** - Free but more code to maintain

**Decision:** Clerk is worth the cost for rapid development and Stripe integration.

### Database: Supabase

**Why Supabase?**

| Feature | Benefit |
|---------|---------|
| PostgreSQL-based | Reliable, standard SQL, complex queries |
| Real-time subscriptions | Live updates across devices |
| Row-Level Security (RLS) | Built-in data isolation |
| TypeScript client | Excellent autocomplete & type safety |
| Generous free tier | 500MB DB, 1GB file storage |
| REST + GraphQL APIs | Flexible data access |
| Self-hostable | Escape hatch if needed |

**Pricing:**
- Free: 500MB database, 1GB file storage, 2GB bandwidth
- Pro: $25/month (8GB DB, 100GB storage, 250GB bandwidth)

**Alternatives Considered:**
- **Firestore** - Good real-time but NoSQL (harder queries)
- **PlanetScale** - MySQL, great DX, more expensive
- **MongoDB Atlas** - NoSQL, overkill for this use case
- **Upstash** - Redis-based, not ideal for relational data

**Decision:** Supabase is the best fit for relational data with real-time sync.

### Hosting: Vercel (Current)

**Why Keep Vercel?**
- Already set up and working
- Automatic HTTPS, global CDN
- Git integration (deploy on push)
- Excellent for Vite/React apps
- Free tier sufficient to start

---

## Data Model

### Critical Privacy Principle

**What Gets Stored in Supabase:**
- âœ… Event IDs (Google Calendar event identifiers)
- âœ… Action types (e.g., "buffer_added", "alert_dismissed")
- âœ… Timestamps (when action was taken)
- âœ… Metadata (minutes saved, alert types)
- âœ… User preferences (timezone, business hours)

**What NEVER Gets Stored:**
- âŒ Calendar event titles
- âŒ Calendar event descriptions
- âŒ Attendee names or emails
- âŒ Meeting content or notes
- âŒ Event locations
- âŒ Any PII from calendar events

**Why This Is Safe:**
Event IDs like `"3qtd8t1b6u3j2gj77a3v9abc12"` are meaningless without Google Calendar access. Even if Supabase is breached, attackers cannot see meeting content.

### Database Schema

#### Table 1: `users`

Synced from Clerk via webhooks.

```sql
CREATE TABLE users (
  id UUID PRIMARY KEY,                    -- Clerk user ID
  email TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  subscription_tier TEXT DEFAULT 'free',  -- 'free', 'pro', 'team'
  subscription_status TEXT,               -- 'active', 'cancelled', 'past_due'
  google_calendar_connected BOOLEAN DEFAULT false,

  -- Indexes
  INDEX idx_users_email (email),
  INDEX idx_users_subscription (subscription_tier, subscription_status)
);
```

**Purpose:** Track user accounts and subscription status.

#### Table 2: `user_actions`

Stores privacy-safe action history.

```sql
CREATE TABLE user_actions (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  event_id TEXT NOT NULL,                 -- Google Calendar event ID
  action_type TEXT NOT NULL,              -- See action types below
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB,                         -- Flexible JSON for action-specific data

  -- Indexes for performance
  INDEX idx_user_actions_user_id (user_id),
  INDEX idx_user_actions_event_id (event_id),
  INDEX idx_user_actions_timestamp (timestamp DESC),
  INDEX idx_user_actions_type (action_type)
);

-- Action types enum (enforced at application level)
-- 'buffer_added'
-- 'meet_link_added'
-- 'travel_block_added'
-- 'alert_dismissed'
-- 'alert_snoozed'
-- 'focus_time_added'
-- 'double_booking_resolved'
-- 'event_moved'
```

**Example Row:**

```json
{
  "id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
  "user_id": "user_2abc123xyz",
  "event_id": "3qtd8t1b6u3j2gj77a3v9abc12",
  "action_type": "buffer_added",
  "timestamp": "2025-10-16T14:30:00Z",
  "metadata": {
    "timeSaved": 15,
    "bufferDuration": 10,
    "beforeEventTitle": null  // Never stored
  }
}
```

**Purpose:** Track user actions for time savings and alert snoozing.

#### Table 3: `user_preferences`

User settings and preferences.

```sql
CREATE TABLE user_preferences (
  user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,

  -- Location & timezone
  home_timezone TEXT DEFAULT 'America/Los_Angeles',
  home_location JSONB,                    -- { city: 'London', country: 'UK', timezone: 'Europe/London' }

  -- Business hours
  business_hours JSONB,                   -- { start: '09:00', end: '17:00' }

  -- Notification settings
  notification_settings JSONB,            -- { email: true, snoozeDuration: 86400000 }

  -- UI preferences
  theme TEXT DEFAULT 'light',             -- 'light' | 'dark' | 'auto'
  default_view TEXT DEFAULT 'today',      -- 'today' | 'week' | 'month'

  updated_at TIMESTAMPTZ DEFAULT NOW()
);
```

**Example Row:**

```json
{
  "user_id": "user_2abc123xyz",
  "home_timezone": "Europe/London",
  "home_location": {
    "city": "London",
    "country": "United Kingdom",
    "timezone": "Europe/London",
    "flag": "ğŸ‡¬ğŸ‡§"
  },
  "business_hours": {
    "start": "09:00",
    "end": "18:00"
  },
  "notification_settings": {
    "emailAlerts": true,
    "snoozeDuration": 86400000
  },
  "theme": "dark",
  "default_view": "week"
}
```

**Purpose:** Store user preferences for cross-device sync.

#### Table 4: `time_savings_summary`

Aggregated statistics for dashboard.

```sql
CREATE TABLE time_savings_summary (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,

  -- Time period
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,

  -- Aggregated metrics
  total_minutes_saved INTEGER DEFAULT 0,
  actions_count INTEGER DEFAULT 0,
  action_breakdown JSONB,                 -- { buffer_added: 5, meet_link_added: 3 }

  -- Unique constraint to prevent duplicates
  UNIQUE(user_id, period_start, period_end),

  -- Indexes
  INDEX idx_time_savings_user_period (user_id, period_start, period_end)
);
```

**Example Row:**

```json
{
  "id": "xyz789-...",
  "user_id": "user_2abc123xyz",
  "period_start": "2025-10-01",
  "period_end": "2025-10-31",
  "total_minutes_saved": 240,
  "actions_count": 18,
  "action_breakdown": {
    "buffer_added": 5,
    "meet_link_added": 8,
    "travel_block_added": 2,
    "focus_time_added": 3
  }
}
```

**Purpose:** Pre-computed stats for fast dashboard rendering.

### Data Retention Policy

- **User actions:** Keep for 90 days, then archive
- **Time savings summary:** Keep indefinitely (aggregated data)
- **User preferences:** Keep until account deletion
- **Deleted users:** CASCADE delete all associated data

---

## Privacy & Security

### Row-Level Security (RLS)

Supabase's built-in RLS ensures users can only access their own data.

```sql
-- Enable RLS on all tables
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_actions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE time_savings_summary ENABLE ROW LEVEL SECURITY;

-- Policy: Users can only access their own data
CREATE POLICY "Users can read own data" ON user_actions
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own data" ON user_actions
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own data" ON user_actions
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own data" ON user_actions
  FOR DELETE USING (auth.uid() = user_id);

-- Repeat for other tables...
```

**How It Works:**
1. Clerk issues JWT token with user ID
2. Supabase validates JWT signature
3. RLS policies check `auth.uid()` matches `user_id`
4. Queries automatically filtered to user's data only

**Result:** Even if application code has bugs, database prevents cross-user access.

### Authentication Flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    User Authentication                       â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

1. User visits CalFix
   â†“
2. User clicks "Sign In with Google" (Clerk)
   â†“
3. Clerk redirects to Google OAuth
   â†“
4. User approves Clerk access
   â†“
5. Clerk creates session, issues JWT
   â†“
6. CalFix receives JWT from Clerk
   â†“
7. User clicks "Connect Google Calendar"
   â†“
8. CalFix initiates Google OAuth PKCE flow
   â†“
9. User approves CalFix calendar access
   â†“
10. Google returns access token
    â†“
11. Access token stored in localStorage
    â†“
12. CalFix fetches calendar data from Google
    â†“
13. Calendar data processed client-side
    â†“
14. Action metadata sent to Supabase (with JWT)
    â†“
15. Supabase validates JWT, stores data with RLS
```

**Key Points:**
- Clerk handles user auth (login, session)
- Google OAuth handles calendar access
- Calendar data NEVER sent to Supabase
- Only action metadata (event IDs) sent to Supabase

### Google OAuth Token Storage

**What Gets Stored Where:**

| Token | Storage Location | Purpose |
|-------|------------------|---------|
| Clerk JWT | Clerk client (memory/cookie) | User authentication |
| Google OAuth Access Token | Browser localStorage | Google Calendar API calls |
| Google OAuth Refresh Token | Browser localStorage | Renew access token |

**Security Measures:**
- Tokens never sent to Supabase
- localStorage cleared on sign out
- Access tokens short-lived (1 hour)
- Refresh tokens rotated on use

### Data Export & Deletion (GDPR/CCPA)

Users can:

1. **Export all data:**
   ```typescript
   async function exportUserData(userId: string) {
     const { data: actions } = await supabase
       .from('user_actions')
       .select('*')
       .eq('user_id', userId);

     const { data: prefs } = await supabase
       .from('user_preferences')
       .select('*')
       .eq('user_id', userId);

     return { actions, preferences: prefs };
   }
   ```

2. **Delete account & data:**
   ```typescript
   async function deleteUserAccount(userId: string) {
     // Clerk webhook triggers on user deletion
     // CASCADE delete in Supabase removes all user data
     await clerk.users.deleteUser(userId);
   }
   ```

---

## Cost Analysis

### Development Costs (One-Time)

| Phase | Hours | Cost @ $100/hr | Notes |
|-------|-------|----------------|-------|
| **Setup & Configuration** | 20-30 | $2,000-$3,000 | Clerk, Supabase, environment |
| **Frontend Integration** | 15-25 | $1,500-$2,500 | Auth flows, protected routes |
| **User Actions Service** | 10-15 | $1,000-$1,500 | Supabase CRUD, migration |
| **User Preferences** | 5-10 | $500-$1,000 | Settings UI, persistence |
| **Billing Integration** | 10-20 | $1,000-$2,000 | Stripe, feature gates |
| **Testing & Polish** | 15-25 | $1,500-$2,500 | QA, bug fixes, UX |
| **Documentation** | 5-10 | $500-$1,000 | User docs, privacy policy |

**Total Development Cost:** $8,000 - $13,500 (80-135 hours)

**Timeline:** 3-4 weeks for one developer

### Monthly Operational Costs

#### Scenario 1: Startup (0-100 users)

| Service | Tier | Cost | Notes |
|---------|------|------|-------|
| Clerk | Free | $0 | Up to 10,000 MAU |
| Supabase | Free | $0 | 500MB DB, 1GB storage |
| Vercel | Free | $0 | Hobby tier |
| Domain | N/A | $1.25/mo | $15/year amortized |

**Total:** $1.25/month

#### Scenario 2: Growing (100-1,000 users)

| Service | Tier | Cost | Notes |
|---------|------|------|-------|
| Clerk | Paid | $25/mo | Base fee |
| Supabase | Free | $0 | Still within limits |
| Vercel | Free | $0 | Still within limits |
| Domain | N/A | $1.25/mo | $15/year |

**Total:** $26.25/month

#### Scenario 3: Established (1,000-10,000 users)

| Service | Tier | Cost | Notes |
|---------|------|------|-------|
| Clerk | Paid | $25 + $20 | Base + 1,000 users @ $0.02 |
| Supabase | Pro | $25/mo | Need more DB space |
| Vercel | Pro | $20/mo | Need more bandwidth |
| Domain | N/A | $1.25/mo | $15/year |

**Total:** $91.25/month

#### Scenario 4: Scale (10,000+ users)

| Service | Tier | Cost | Notes |
|---------|------|------|-------|
| Clerk | Paid | $225/mo | Base + 10,000 users @ $0.02 |
| Supabase | Pro | $25/mo | May need Team ($599) at scale |
| Vercel | Pro | $20/mo | May need Enterprise |
| Domain | N/A | $1.25/mo | $15/year |

**Total:** $271.25/month (or $799+ at higher scale)

### Revenue Model & Break-Even

**Pricing Tiers (Example):**

| Tier | Price/User/Month | Features |
|------|------------------|----------|
| Free | $0 | Basic analytics, manual actions |
| Pro | $10 | Advanced analytics, auto-optimization, time tracking |
| Team | $20 | Multi-calendar, team scheduling, API access |

**Break-Even Analysis:**

At $10/user/month (Pro tier):
- **5 paying users** = $50/mo revenue â†’ Break-even at 100 users
- **10 paying users** = $100/mo revenue â†’ Profitable at 100 users
- **50 paying users** = $500/mo revenue â†’ Covers 1,000+ users
- **100 paying users** = $1,000/mo revenue â†’ Significant profit

**Conversion Rate Assumptions:**
- 10% free â†’ Pro conversion = Profitable at 100 free users
- 5% free â†’ Pro conversion = Need 200 free users to break even

---

## Implementation Plan

### Phase 1: Setup & Configuration (Week 1)

**Duration:** 3-5 days

#### 1.1 Clerk Setup

**Tasks:**
- [ ] Create Clerk account at https://clerk.com
- [ ] Create new application in Clerk dashboard
- [ ] Configure OAuth providers:
  - [ ] Enable Google OAuth
  - [ ] Enable email/password auth
- [ ] Set up Stripe integration:
  - [ ] Connect Stripe account
  - [ ] Create subscription products
  - [ ] Configure pricing tiers (Free, Pro, Team)
- [ ] Configure webhooks:
  - [ ] User created â†’ Sync to Supabase
  - [ ] User updated â†’ Update Supabase
  - [ ] User deleted â†’ CASCADE delete in Supabase
  - [ ] Subscription changed â†’ Update user tier
- [ ] Copy API keys to `.env`:
  ```env
  VITE_CLERK_PUBLISHABLE_KEY=pk_test_...
  CLERK_SECRET_KEY=sk_test_...
  CLERK_WEBHOOK_SECRET=whsec_...
  ```

**Deliverables:**
- âœ… Clerk application configured
- âœ… OAuth providers enabled
- âœ… Stripe connected
- âœ… Webhooks configured
- âœ… API keys in `.env`

#### 1.2 Supabase Setup

**Tasks:**
- [ ] Create Supabase account at https://supabase.com
- [ ] Create new project
- [ ] Create database schema:
  - [ ] Run SQL migration for `users` table
  - [ ] Run SQL migration for `user_actions` table
  - [ ] Run SQL migration for `user_preferences` table
  - [ ] Run SQL migration for `time_savings_summary` table
- [ ] Configure Row-Level Security (RLS):
  - [ ] Enable RLS on all tables
  - [ ] Create policies for SELECT, INSERT, UPDATE, DELETE
- [ ] Set up Clerk <> Supabase JWT integration:
  - [ ] Get Clerk JWKS endpoint
  - [ ] Configure in Supabase dashboard
- [ ] Create database indexes for performance
- [ ] Copy API keys to `.env`:
  ```env
  VITE_SUPABASE_URL=https://xxx.supabase.co
  VITE_SUPABASE_ANON_KEY=eyJhbGc...
  SUPABASE_SERVICE_ROLE_KEY=eyJhbGc...  # Backend only
  ```

**Deliverables:**
- âœ… Supabase project created
- âœ… Database schema deployed
- âœ… RLS policies active
- âœ… Clerk JWT integration working
- âœ… API keys in `.env`

#### 1.3 Environment Variables

**Update `.env` file:**

```env
# Port
VITE_PORT=3001

# Google OAuth (existing)
VITE_GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
VITE_GOOGLE_CLIENT_SECRET=your-client-secret
VITE_REDIRECT_URI=http://localhost:3001

# Clerk (new)
VITE_CLERK_PUBLISHABLE_KEY=pk_test_...
CLERK_SECRET_KEY=sk_test_...
CLERK_WEBHOOK_SECRET=whsec_...

# Supabase (new)
VITE_SUPABASE_URL=https://xxx.supabase.co
VITE_SUPABASE_ANON_KEY=eyJhbGc...
SUPABASE_SERVICE_ROLE_KEY=eyJhbGc...
```

**Create `.env.example` for documentation:**

```env
# Port
VITE_PORT=3001

# Google OAuth
VITE_GOOGLE_CLIENT_ID=your-client-id.apps.googleusercontent.com
VITE_GOOGLE_CLIENT_SECRET=your-client-secret
VITE_REDIRECT_URI=http://localhost:3001

# Clerk
VITE_CLERK_PUBLISHABLE_KEY=pk_test_your-key
CLERK_SECRET_KEY=sk_test_your-key
CLERK_WEBHOOK_SECRET=whsec_your-secret

# Supabase
VITE_SUPABASE_URL=https://your-project.supabase.co
VITE_SUPABASE_ANON_KEY=your-anon-key
SUPABASE_SERVICE_ROLE_KEY=your-service-role-key
```

---

### Phase 2: Frontend Integration (Week 1-2)

**Duration:** 5-7 days

#### 2.1 Install Dependencies

```bash
npm install @clerk/clerk-react @supabase/supabase-js
```

#### 2.2 Wrap App with Clerk Provider

**Update `src/main.tsx`:**

```typescript
import { StrictMode } from 'react';
import ReactDOM from 'react-dom/client';
import { ClerkProvider } from '@clerk/clerk-react';
import './index.css';
import App from './App';

const clerkPubKey = import.meta.env.VITE_CLERK_PUBLISHABLE_KEY;

if (!clerkPubKey) {
  throw new Error('Missing Clerk Publishable Key');
}

const root = ReactDOM.createRoot(document.getElementById('root') as HTMLElement);
root.render(
  <StrictMode>
    <ClerkProvider publishableKey={clerkPubKey}>
      <App />
    </ClerkProvider>
  </StrictMode>
);
```

#### 2.3 Create Auth Components

**Tasks:**
- [ ] Create `src/components/SignInPage.tsx`
- [ ] Create `src/components/SignUpPage.tsx`
- [ ] Create `src/components/UserProfile.tsx`
- [ ] Create `src/components/ProtectedRoute.tsx`

**Example `ProtectedRoute.tsx`:**

```typescript
import { useAuth } from '@clerk/clerk-react';
import { Navigate } from 'react-router-dom';

export function ProtectedRoute({ children }: { children: React.ReactNode }) {
  const { isSignedIn, isLoaded } = useAuth();

  if (!isLoaded) {
    return <div>Loading...</div>;
  }

  if (!isSignedIn) {
    return <Navigate to="/sign-in" replace />;
  }

  return <>{children}</>;
}
```

#### 2.4 Update Routing

**Install React Router:**

```bash
npm install react-router-dom
```

**Update `src/App.tsx`:**

```typescript
import { BrowserRouter, Routes, Route, Navigate } from 'react-router-dom';
import { useAuth } from '@clerk/clerk-react';
import SignInPage from './components/SignInPage';
import SignUpPage from './components/SignUpPage';
import CalendarDashboard from './components/CalendarDashboard';
import ProtectedRoute from './components/ProtectedRoute';

function App() {
  const { isSignedIn } = useAuth();

  return (
    <BrowserRouter>
      <Routes>
        <Route path="/sign-in" element={<SignInPage />} />
        <Route path="/sign-up" element={<SignUpPage />} />
        <Route
          path="/dashboard"
          element={
            <ProtectedRoute>
              <CalendarDashboard />
            </ProtectedRoute>
          }
        />
        <Route
          path="/"
          element={
            isSignedIn ? <Navigate to="/dashboard" /> : <Navigate to="/sign-in" />
          }
        />
      </Routes>
    </BrowserRouter>
  );
}

export default App;
```

#### 2.5 Initialize Supabase Client

**Create `src/lib/supabase.ts`:**

```typescript
import { createClient } from '@supabase/supabase-js';
import { useAuth } from '@clerk/clerk-react';

const supabaseUrl = import.meta.env.VITE_SUPABASE_URL;
const supabaseAnonKey = import.meta.env.VITE_SUPABASE_ANON_KEY;

if (!supabaseUrl || !supabaseAnonKey) {
  throw new Error('Missing Supabase environment variables');
}

/**
 * Hook to get authenticated Supabase client
 * Uses Clerk JWT for authentication
 */
export function useSupabaseClient() {
  const { getToken } = useAuth();

  const getAuthenticatedClient = async () => {
    const token = await getToken({ template: 'supabase' });

    return createClient(supabaseUrl, supabaseAnonKey, {
      global: {
        headers: token ? { Authorization: `Bearer ${token}` } : {},
      },
    });
  };

  return getAuthenticatedClient;
}
```

#### 2.6 Migrate localStorage to Supabase

**Create migration utility `src/utils/migrateLocalStorage.ts`:**

```typescript
import { useSupabaseClient } from '../lib/supabase';

export async function migrateLocalStorageToSupabase() {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  // Check if already migrated
  const migrated = localStorage.getItem('migrated_to_supabase');
  if (migrated === 'true') {
    return { alreadyMigrated: true };
  }

  // Get localStorage data
  const actionsJson = localStorage.getItem('calfix_user_actions');
  if (!actionsJson) {
    localStorage.setItem('migrated_to_supabase', 'true');
    return { migratedCount: 0 };
  }

  const { actions } = JSON.parse(actionsJson);

  // Insert into Supabase
  const { data, error } = await supabase
    .from('user_actions')
    .insert(actions);

  if (error) {
    console.error('Migration error:', error);
    throw error;
  }

  // Mark as migrated
  localStorage.setItem('migrated_to_supabase', 'true');

  // Keep localStorage as backup for now
  // localStorage.removeItem('calfix_user_actions');

  return { migratedCount: actions.length };
}
```

**Prompt user on first login:**

```typescript
// In CalendarDashboard.tsx or App.tsx
useEffect(() => {
  const runMigration = async () => {
    try {
      const result = await migrateLocalStorageToSupabase();
      if (result.migratedCount > 0) {
        alert(`Migrated ${result.migratedCount} actions to cloud storage!`);
      }
    } catch (error) {
      console.error('Migration failed:', error);
    }
  };

  runMigration();
}, []);
```

**Deliverables:**
- âœ… Clerk Provider integrated
- âœ… Auth pages created
- âœ… Protected routes working
- âœ… Supabase client initialized
- âœ… Migration utility ready

---

### Phase 3: User Actions Service (Week 2)

**Duration:** 3-5 days

#### 3.1 Create Supabase User Actions Service

**Create `src/services/userActionsSupabase.ts`:**

```typescript
import { useSupabaseClient } from '../lib/supabase';

export interface UserAction {
  id?: string;
  user_id?: string;
  event_id: string;
  action_type: 'buffer_added' | 'meet_link_added' | 'travel_block_added' |
                'alert_dismissed' | 'alert_snoozed' | 'focus_time_added' |
                'double_booking_resolved' | 'event_moved';
  timestamp?: Date;
  metadata?: {
    timeSaved?: number;
    snoozedUntil?: number;
    alertType?: string;
    [key: string]: any;
  };
}

/**
 * Record a user action in Supabase
 */
export async function recordAction(
  eventId: string,
  actionType: UserAction['action_type'],
  metadata?: UserAction['metadata']
) {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_actions')
    .insert({
      event_id: eventId,
      action_type: actionType,
      metadata: metadata || {},
    })
    .select()
    .single();

  if (error) throw error;
  return data;
}

/**
 * Get all user actions
 */
export async function getUserActions(limit = 1000): Promise<UserAction[]> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_actions')
    .select('*')
    .order('timestamp', { ascending: false })
    .limit(limit);

  if (error) throw error;
  return data || [];
}

/**
 * Check if alert has been dismissed
 */
export async function isAlertDismissed(
  eventId: string,
  alertType: string
): Promise<boolean> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_actions')
    .select('id')
    .eq('event_id', eventId)
    .eq('action_type', 'alert_dismissed')
    .eq('metadata->>alertType', alertType)
    .limit(1);

  if (error) throw error;
  return (data?.length || 0) > 0;
}

/**
 * Check if alert is currently snoozed
 */
export async function isAlertSnoozed(
  eventId: string,
  alertType: string
): Promise<boolean> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();
  const now = Date.now();

  const { data, error } = await supabase
    .from('user_actions')
    .select('metadata')
    .eq('event_id', eventId)
    .eq('action_type', 'alert_snoozed')
    .eq('metadata->>alertType', alertType)
    .gt('metadata->snoozedUntil', now)
    .limit(1);

  if (error) throw error;
  return (data?.length || 0) > 0;
}

/**
 * Get total time saved
 */
export async function getTotalTimeSaved(): Promise<number> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_actions')
    .select('metadata')
    .not('metadata->>timeSaved', 'is', null);

  if (error) throw error;

  return (data || []).reduce((total, action) => {
    return total + (action.metadata?.timeSaved || 0);
  }, 0);
}

/**
 * Get time saved in date range
 */
export async function getTimeSavedInPeriod(
  startDate: Date,
  endDate: Date
): Promise<number> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_actions')
    .select('metadata')
    .gte('timestamp', startDate.toISOString())
    .lte('timestamp', endDate.toISOString())
    .not('metadata->>timeSaved', 'is', null);

  if (error) throw error;

  return (data || []).reduce((total, action) => {
    return total + (action.metadata?.timeSaved || 0);
  }, 0);
}

/**
 * Get action statistics by type
 */
export async function getActionStats(): Promise<Record<string, number>> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_actions')
    .select('action_type');

  if (error) throw error;

  const stats: Record<string, number> = {};
  (data || []).forEach(action => {
    stats[action.action_type] = (stats[action.action_type] || 0) + 1;
  });

  return stats;
}

/**
 * Clean up old actions (older than 90 days)
 */
export async function cleanupOldActions(): Promise<number> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const cutoffDate = new Date();
  cutoffDate.setDate(cutoffDate.getDate() - 90);

  const { data, error } = await supabase
    .from('user_actions')
    .delete()
    .lt('timestamp', cutoffDate.toISOString())
    .select();

  if (error) throw error;
  return data?.length || 0;
}
```

#### 3.2 Update Components to Use Supabase

**Tasks:**
- [ ] Replace `recordAction()` calls with Supabase version
- [ ] Update `isAlertDismissed()` checks
- [ ] Update time savings display
- [ ] Add loading states for async operations
- [ ] Add error handling for network failures
- [ ] Implement optimistic updates for better UX

**Example optimistic update:**

```typescript
// Optimistically update UI
setActions(prev => [...prev, newAction]);

try {
  // Save to Supabase
  await recordAction(eventId, actionType, metadata);
} catch (error) {
  // Rollback on error
  setActions(prev => prev.filter(a => a !== newAction));
  alert('Failed to save action. Please try again.');
}
```

**Deliverables:**
- âœ… Supabase user actions service created
- âœ… Components updated to use Supabase
- âœ… Loading states added
- âœ… Error handling implemented
- âœ… Optimistic updates working

---

### Phase 4: User Preferences (Week 2)

**Duration:** 2-3 days

#### 4.1 Create Preferences Service

**Create `src/services/userPreferences.ts`:**

```typescript
import { useSupabaseClient } from '../lib/supabase';

export interface UserPreferences {
  user_id?: string;
  home_timezone: string;
  home_location?: {
    city: string;
    country: string;
    timezone: string;
    flag: string;
  };
  business_hours?: {
    start: string;
    end: string;
  };
  notification_settings?: {
    emailAlerts: boolean;
    snoozeDuration: number;
  };
  theme: 'light' | 'dark' | 'auto';
  default_view: 'today' | 'tomorrow' | 'week' | 'month';
}

export async function getUserPreferences(): Promise<UserPreferences | null> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_preferences')
    .select('*')
    .single();

  if (error && error.code !== 'PGRST116') { // PGRST116 = no rows
    throw error;
  }

  return data;
}

export async function updateUserPreferences(
  prefs: Partial<UserPreferences>
): Promise<UserPreferences> {
  const getClient = useSupabaseClient();
  const supabase = await getClient();

  const { data, error } = await supabase
    .from('user_preferences')
    .upsert(prefs)
    .select()
    .single();

  if (error) throw error;
  return data;
}
```

#### 4.2 Create Settings Page

**Create `src/components/SettingsPage.tsx`:**

- Timezone selector
- Home location configurator
- Business hours picker
- Notification preferences
- Theme switcher
- Default view selector

#### 4.3 Add Real-Time Sync

**Use Supabase real-time subscriptions for cross-device sync:**

```typescript
useEffect(() => {
  const getClient = useSupabaseClient();

  const setupSubscription = async () => {
    const supabase = await getClient();

    const subscription = supabase
      .channel('user_preferences_changes')
      .on(
        'postgres_changes',
        {
          event: 'UPDATE',
          schema: 'public',
          table: 'user_preferences',
        },
        (payload) => {
          console.log('Preferences updated on another device:', payload);
          setPreferences(payload.new);
        }
      )
      .subscribe();

    return () => {
      subscription.unsubscribe();
    };
  };

  setupSubscription();
}, []);
```

**Deliverables:**
- âœ… Preferences service created
- âœ… Settings page UI built
- âœ… Real-time sync working
- âœ… Cross-device updates instant

---

### Phase 5: Billing Integration (Week 3)

**Duration:** 3-5 days

#### 5.1 Configure Stripe in Clerk

**Tasks:**
- [ ] Connect Stripe account to Clerk
- [ ] Create subscription products in Stripe:
  - [ ] Free tier ($0/month)
  - [ ] Pro tier ($10/month)
  - [ ] Team tier ($20/month)
- [ ] Configure Clerk to sync subscription status
- [ ] Set up webhooks for subscription events

#### 5.2 Create Feature Gates

**Create `src/lib/featureGates.ts`:**

```typescript
import { useUser } from '@clerk/clerk-react';

export type SubscriptionTier = 'free' | 'pro' | 'team';

export interface FeatureAccess {
  // Free tier
  basicAnalytics: boolean;
  manualActions: boolean;

  // Pro tier
  advancedAnalytics: boolean;
  autoOptimization: boolean;
  timeTracking: boolean;

  // Team tier
  multiCalendar: boolean;
  teamScheduling: boolean;
  apiAccess: boolean;
}

const featureMatrix: Record<SubscriptionTier, FeatureAccess> = {
  free: {
    basicAnalytics: true,
    manualActions: true,
    advancedAnalytics: false,
    autoOptimization: false,
    timeTracking: false,
    multiCalendar: false,
    teamScheduling: false,
    apiAccess: false,
  },
  pro: {
    basicAnalytics: true,
    manualActions: true,
    advancedAnalytics: true,
    autoOptimization: true,
    timeTracking: true,
    multiCalendar: false,
    teamScheduling: false,
    apiAccess: false,
  },
  team: {
    basicAnalytics: true,
    manualActions: true,
    advancedAnalytics: true,
    autoOptimization: true,
    timeTracking: true,
    multiCalendar: true,
    teamScheduling: true,
    apiAccess: true,
  },
};

export function useFeatureAccess(): FeatureAccess {
  const { user } = useUser();
  const tier = (user?.publicMetadata?.subscriptionTier as SubscriptionTier) || 'free';
  return featureMatrix[tier];
}

export function useCanAccessFeature(feature: keyof FeatureAccess): boolean {
  const access = useFeatureAccess();
  return access[feature];
}
```

#### 5.3 Add Upgrade CTAs

**Create upgrade prompts for premium features:**

```typescript
function AdvancedAnalyticsSection() {
  const canAccess = useCanAccessFeature('advancedAnalytics');

  if (!canAccess) {
    return (
      <div className="upgrade-prompt">
        <h3>Advanced Analytics</h3>
        <p>Unlock detailed insights and trends</p>
        <button onClick={() => window.location.href = '/upgrade'}>
          Upgrade to Pro
        </button>
      </div>
    );
  }

  return <AdvancedAnalytics />;
}
```

#### 5.4 Create Subscription Management Page

**Create `src/components/SubscriptionPage.tsx`:**

- Display current plan
- Show feature comparison
- Upgrade/downgrade buttons
- Stripe checkout integration
- Billing history

**Deliverables:**
- âœ… Stripe configured in Clerk
- âœ… Feature gates implemented
- âœ… Upgrade CTAs added
- âœ… Subscription management page built
- âœ… Checkout flow working

---

### Phase 6: Testing & Deployment (Week 3)

**Duration:** 5-7 days

#### 6.1 Testing Checklist

**Authentication:**
- [ ] Sign up with email works
- [ ] Sign up with Google works
- [ ] Sign in with email works
- [ ] Sign in with Google works
- [ ] Password reset works
- [ ] User profile updates
- [ ] Sign out works
- [ ] Session persistence across page refresh

**Google Calendar Integration:**
- [ ] OAuth flow after Clerk auth works
- [ ] Calendar data fetches correctly
- [ ] Actions modify calendar successfully
- [ ] Tokens refresh automatically
- [ ] Multiple calendars supported

**User Actions:**
- [ ] Actions saved to Supabase
- [ ] Actions retrieved correctly
- [ ] Alert dismissal works
- [ ] Alert snoozing works
- [ ] Time savings calculated correctly
- [ ] Cross-device sync works

**Preferences:**
- [ ] Settings save to Supabase
- [ ] Settings load on app start
- [ ] Real-time sync across devices
- [ ] Theme changes apply immediately

**Billing:**
- [ ] Stripe checkout works
- [ ] Subscription created in Clerk
- [ ] Feature gates enforce correctly
- [ ] Upgrade/downgrade works
- [ ] Webhook events processed

**Security:**
- [ ] RLS policies prevent cross-user access
- [ ] JWT validation works
- [ ] Unauthorized requests blocked
- [ ] HTTPS enforced in production

**Edge Cases:**
- [ ] Offline mode (localStorage fallback)
- [ ] Network error handling
- [ ] Loading states show correctly
- [ ] Empty states handled
- [ ] Large datasets perform well

#### 6.2 Performance Testing

**Metrics to test:**
- Page load time < 2 seconds
- Calendar fetch < 1 second
- Action save < 500ms
- Real-time sync latency < 200ms

**Tools:**
- Lighthouse audit
- Chrome DevTools Performance tab
- Supabase query analyzer

#### 6.3 Deployment

**Staging Environment:**

```bash
# Deploy to Vercel staging
vercel --prod --env-file .env.staging

# Update environment variables in Vercel dashboard
# - VITE_CLERK_PUBLISHABLE_KEY
# - VITE_SUPABASE_URL
# - VITE_SUPABASE_ANON_KEY
# - VITE_GOOGLE_CLIENT_ID
# - VITE_GOOGLE_CLIENT_SECRET
# - VITE_REDIRECT_URI (https://staging.calfix.com)
```

**Production Environment:**

```bash
# Deploy to Vercel production
vercel --prod

# Update production environment variables
# - Switch to production Clerk keys
# - Switch to production Supabase keys
# - Update Google OAuth redirect URI
```

**Post-Deployment:**
- [ ] Verify all features work in production
- [ ] Test payment flow with real Stripe
- [ ] Monitor error logs
- [ ] Check analytics

**Deliverables:**
- âœ… All tests passing
- âœ… Performance benchmarks met
- âœ… Staging deployed and tested
- âœ… Production deployed
- âœ… Monitoring set up

---

## Deployment Strategy

### Environments

| Environment | URL | Purpose | Clerk | Supabase | Google OAuth |
|-------------|-----|---------|-------|----------|--------------|
| **Development** | localhost:3001 | Local testing | Test mode | Dev project | localhost redirect |
| **Staging** | staging.calfix.com | Pre-production | Test mode | Staging project | Staging redirect |
| **Production** | calfix.com | Live users | Production | Production project | Production redirect (verified) |

### Deployment Checklist

**Before First Production Deploy:**

- [ ] Purchase domain (calfix.com)
- [ ] Configure DNS (Vercel)
- [ ] Set up SSL (automatic with Vercel)
- [ ] Submit Google OAuth for verification (2-4 weeks)
- [ ] Create privacy policy page
- [ ] Create terms of service page
- [ ] Update CLAUDE.md with new architecture
- [ ] Write user documentation
- [ ] Set up error tracking (Sentry)
- [ ] Set up analytics (Posthog, Mixpanel, or Google Analytics)

**Continuous Deployment:**

- Set up GitHub Actions or Vercel Git integration
- Automatic deploys on push to `main` branch
- Preview deploys for pull requests

---

## Risk Mitigation

### Risk 1: Data Breach of Supabase

**Likelihood:** Low (Supabase has strong security)
**Impact:** Medium (only event IDs exposed, not calendar content)

**Mitigation:**
- Only store event IDs, never calendar content
- Row-Level Security prevents cross-user access
- Regular security audits
- Encrypt sensitive fields if adding PII later
- Monitor for suspicious activity

**Response Plan:**
- Immediate password reset for all users
- Notify affected users within 72 hours (GDPR requirement)
- Investigate breach vector
- Implement additional security measures

### Risk 2: Vendor Lock-In

**Likelihood:** Medium
**Impact:** High (difficult to migrate)

**Mitigation:**
- **Clerk:** Has export API, can migrate to Auth0 or Supabase Auth
- **Supabase:** Open-source, can self-host if needed
- **Google Calendar API:** Standard API, not locked in
- Regular data exports for backup

**Response Plan:**
- Maintain data export functionality
- Document migration procedures
- Keep schema compatible with other databases

### Risk 3: Cost Explosion

**Likelihood:** Medium (as you scale)
**Impact:** High (erodes profit margins)

**Mitigation:**
- Set up billing alerts in Clerk/Supabase dashboards
- Implement rate limiting (max API calls per user)
- Archive old user actions (>90 days) to cold storage
- Monitor Monthly Active Users (MAU) closely
- Optimize database queries

**Response Plan:**
- Increase prices if necessary
- Optimize infrastructure
- Consider self-hosting Supabase at scale

### Risk 4: Sync Conflicts

**Likelihood:** Medium (multi-device users)
**Impact:** Low (user frustration)

**Mitigation:**
- Use Supabase real-time subscriptions for instant sync
- Implement last-write-wins for preferences
- Show sync status indicator in UI
- Handle offline mode gracefully

**Response Plan:**
- Add conflict resolution UI
- Allow manual refresh
- Log sync errors for debugging

### Risk 5: Google OAuth Verification Rejected

**Likelihood:** Low (if following guidelines)
**Impact:** High (cannot go to production)

**Mitigation:**
- Follow all Google guidelines carefully
- Create high-quality demonstration video
- Write clear, accurate privacy policy
- Respond quickly to Google feedback
- Prepare alternative auth methods (email/password)

**Response Plan:**
- Address Google's concerns immediately
- Resubmit with requested changes
- Use Testing mode with manual user approval as fallback

---

## Privacy Policy Updates

Since you're now storing user data, update your privacy policy to reflect:

### What You Collect

**From Clerk:**
- Email address
- Name
- OAuth provider info (if using Google sign-in)

**From Google Calendar:**
- Calendar event IDs (only IDs, not content)
- No event titles, descriptions, or attendee information

**User-Provided:**
- Timezone preferences
- Business hours settings
- UI preferences (theme, default view)

### How You Use Data

**Event IDs:**
- Track which events had optimizations applied
- Implement alert snoozing (dismiss permanently or temporarily)
- Calculate time savings statistics

**Preferences:**
- Personalize user experience
- Sync settings across devices

**Email:**
- Account management
- Subscription billing
- Optional notifications (user can opt out)

### Data Storage & Security

- User data stored in Supabase (PostgreSQL database)
- Row-Level Security prevents cross-user access
- Calendar event data processed **client-side only**
- No calendar content ever stored on servers
- Data encrypted in transit (HTTPS) and at rest

### Data Retention

- User actions: 90 days, then archived
- Preferences: Until account deletion
- Aggregated statistics: Indefinite (anonymized)
- Account deletion: All user data CASCADE deleted within 30 days

### Third-Party Services

- **Clerk:** User authentication and session management
- **Supabase:** Database hosting and real-time sync
- **Google Calendar API:** Calendar data access (direct, not via CalFix servers)
- **Stripe:** Payment processing (via Clerk integration)

### User Rights (GDPR/CCPA)

- **Right to access:** Export all data via Settings page
- **Right to delete:** Delete account and all data permanently
- **Right to portability:** Download data in JSON format
- **Right to rectification:** Update preferences anytime

### Contact Information

Include email for privacy inquiries: privacy@calfix.com

---

## Timeline & Next Steps

### Development Timeline

| Week | Phase | Key Milestones |
|------|-------|----------------|
| **Week 1** | Setup + Frontend | Clerk & Supabase configured, auth flows working |
| **Week 2** | User Actions + Prefs | Data persistence working, settings page complete |
| **Week 3** | Billing + Testing | Stripe integrated, all tests passing |
| **Week 4** | Deployment + Polish | Staging deployed, production ready |

**Total: 4 weeks** for one developer

### Immediate Next Steps

**This Week:**
1. Sign up for Clerk account
2. Sign up for Supabase account
3. Experiment with both platforms
4. Review pricing and free tier limits

**Next Week:**
1. Start Phase 1 (Setup & Configuration)
2. Create database schema in Supabase
3. Configure Clerk webhooks
4. Set up development environment

**Month 1 Goal:** Complete implementation, deploy to staging

**Month 2 Goal:** User testing, bug fixes, deploy to production

**Month 3 Goal:** Marketing, user acquisition, iterate based on feedback

### Success Metrics

**Technical:**
- [ ] 100% uptime in production
- [ ] < 2 second page load time
- [ ] < 500ms action save time
- [ ] Zero cross-user data leaks
- [ ] All tests green

**Business:**
- [ ] 100 free users in Month 1
- [ ] 10 paying users in Month 2
- [ ] 50 paying users in Month 3
- [ ] 5% free â†’ paid conversion rate
- [ ] $500/month revenue by Month 3

---

## Appendix

### Alternative Architectures Considered

#### Option 1: Supabase Auth Instead of Clerk

**Pros:**
- No per-user costs (save $0.02/user)
- Tighter integration with Supabase
- Open-source, can self-host

**Cons:**
- More code to write (auth UI, email templates)
- No built-in Stripe integration
- Less polished developer experience

**Decision:** Clerk chosen for speed-to-market and Stripe integration. Can migrate later if costs become issue.

#### Option 2: Firebase Instead of Supabase

**Pros:**
- Excellent real-time sync
- Google ecosystem integration
- Free tier generous

**Cons:**
- NoSQL (Firestore) - harder complex queries
- Vendor lock-in to Google
- Pricing can scale unpredictably

**Decision:** Supabase chosen for PostgreSQL and self-hosting option.

#### Option 3: Build Custom Backend

**Pros:**
- Complete control
- No per-user costs
- Customizable

**Cons:**
- 10x more development time
- Need to maintain infrastructure
- Security responsibility
- Hosting costs

**Decision:** Not worth it for MVP. Use managed services to ship faster.

### SQL Migrations

**Complete SQL schema to run in Supabase:**

```sql
-- Enable UUID extension
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- Users table (synced from Clerk)
CREATE TABLE users (
  id UUID PRIMARY KEY,
  email TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ DEFAULT NOW(),
  updated_at TIMESTAMPTZ DEFAULT NOW(),
  subscription_tier TEXT DEFAULT 'free',
  subscription_status TEXT,
  google_calendar_connected BOOLEAN DEFAULT false
);

CREATE INDEX idx_users_email ON users(email);
CREATE INDEX idx_users_subscription ON users(subscription_tier, subscription_status);

-- User actions table
CREATE TABLE user_actions (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  event_id TEXT NOT NULL,
  action_type TEXT NOT NULL,
  timestamp TIMESTAMPTZ DEFAULT NOW(),
  metadata JSONB
);

CREATE INDEX idx_user_actions_user_id ON user_actions(user_id);
CREATE INDEX idx_user_actions_event_id ON user_actions(event_id);
CREATE INDEX idx_user_actions_timestamp ON user_actions(timestamp DESC);
CREATE INDEX idx_user_actions_type ON user_actions(action_type);

-- User preferences table
CREATE TABLE user_preferences (
  user_id UUID PRIMARY KEY REFERENCES users(id) ON DELETE CASCADE,
  home_timezone TEXT DEFAULT 'America/Los_Angeles',
  home_location JSONB,
  business_hours JSONB,
  notification_settings JSONB,
  theme TEXT DEFAULT 'light',
  default_view TEXT DEFAULT 'today',
  updated_at TIMESTAMPTZ DEFAULT NOW()
);

-- Time savings summary table
CREATE TABLE time_savings_summary (
  id UUID PRIMARY KEY DEFAULT uuid_generate_v4(),
  user_id UUID REFERENCES users(id) ON DELETE CASCADE,
  period_start DATE NOT NULL,
  period_end DATE NOT NULL,
  total_minutes_saved INTEGER DEFAULT 0,
  actions_count INTEGER DEFAULT 0,
  action_breakdown JSONB,
  UNIQUE(user_id, period_start, period_end)
);

CREATE INDEX idx_time_savings_user_period ON time_savings_summary(user_id, period_start, period_end);

-- Enable Row-Level Security
ALTER TABLE users ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_actions ENABLE ROW LEVEL SECURITY;
ALTER TABLE user_preferences ENABLE ROW LEVEL SECURITY;
ALTER TABLE time_savings_summary ENABLE ROW LEVEL SECURITY;

-- RLS Policies for user_actions
CREATE POLICY "Users can read own actions" ON user_actions
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own actions" ON user_actions
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own actions" ON user_actions
  FOR UPDATE USING (auth.uid() = user_id);

CREATE POLICY "Users can delete own actions" ON user_actions
  FOR DELETE USING (auth.uid() = user_id);

-- RLS Policies for user_preferences
CREATE POLICY "Users can read own preferences" ON user_preferences
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own preferences" ON user_preferences
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own preferences" ON user_preferences
  FOR UPDATE USING (auth.uid() = user_id);

-- RLS Policies for time_savings_summary
CREATE POLICY "Users can read own summaries" ON time_savings_summary
  FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own summaries" ON time_savings_summary
  FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own summaries" ON time_savings_summary
  FOR UPDATE USING (auth.uid() = user_id);

-- Function to update updated_at timestamp
CREATE OR REPLACE FUNCTION update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ language 'plpgsql';

-- Trigger to auto-update updated_at
CREATE TRIGGER update_users_updated_at BEFORE UPDATE ON users
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();

CREATE TRIGGER update_preferences_updated_at BEFORE UPDATE ON user_preferences
  FOR EACH ROW EXECUTE FUNCTION update_updated_at_column();
```

### Useful Resources

**Clerk:**
- Documentation: https://clerk.com/docs
- React quickstart: https://clerk.com/docs/quickstarts/react
- Stripe integration: https://clerk.com/docs/payments/stripe

**Supabase:**
- Documentation: https://supabase.com/docs
- Auth with Clerk: https://supabase.com/docs/guides/auth/third-party/clerk
- RLS guide: https://supabase.com/docs/guides/auth/row-level-security

**Google Calendar API:**
- API reference: https://developers.google.com/calendar/api/v3/reference
- OAuth verification: https://support.google.com/cloud/answer/9110914

**General:**
- GDPR compliance: https://gdpr.eu/
- CCPA compliance: https://oag.ca.gov/privacy/ccpa

---

## Document Metadata

**Version:** 1.0
**Created:** October 2025
**Last Updated:** October 2025
**Next Review:** After Phase 1 completion

**Change Log:**
- v1.0 - Initial document created

**Status:** âœ… Ready for implementation
